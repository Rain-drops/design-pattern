# 观察者模式/发布-订阅模式(Observer Pattern)

## 概述
定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。

在以下任一情况下可以使用观察者模式：  
（1）当一个抽象模型有两个方面，其一个方面依赖于另一方面。将这二者封装在独立的对象中，以使它们可以各自独立的改变和复用；  
（2）当对一个对象改变需要同时改变其他对象，而又不知道具体有多少对象有待改变；  
（3）当一个对象必须通知其他对象，而它又不能假定其它对象是谁。换言之，这些对象是松耦合的，甚至相互之间不知道对方的存在。  

优点  
（1）观察者和被观察者是抽象耦合的。  
（2）建立一套触发机制。  
（3）增强系统的灵活性、可扩展性。  
缺点  
（1）如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。  
（2）如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。  
（3）观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。  
（4）开发调试比较麻烦  

## 结构图


## 角色
Subject/Observable（目标/被观察者）  
（1）把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任何数量的观察者。  
（2）提供注册和删除观察者对象的接口。  

Observer（观察者）  
（1）为所有的具体观察者定义一个接口，在得到主题通知时更新自己。  

ConcreteSubject（具体目标）  
（1）将有关状态存入各ConcreteObserver对象；  
（2）当它的状态发生改变时，向它的各个观察者发出通知。  

ConcreteObserver(具体观察者)  
（1）维护一个指向ConcreteSubject对象的引用；  
（2）存储有关状态，这些状态应与目标的状态保持一致；  
（3）实现Observer的更新接口以使自身状态与目标的状态保持一致。  

## 使用场景


## 源码解析